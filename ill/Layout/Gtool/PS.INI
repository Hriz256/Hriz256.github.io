%!PS
%----- Define RECTANGLE procedure 
%lx ly ux uy fill_flag rt
/rt { gsave newpath 
/flag exch def
/uy exch def
/ux exch def
/ly exch def
/lx exch def
lx ly moveto
ux ly lineto
ux uy lineto
lx uy lineto
lx ly lineto
1 setlinewidth closepath
flag 1 eq {fill} if stroke grestore } def
%----- Define POLYGON procedure 
%[xn yn ... x1 y1] fill_flag pl
/pl {gsave newpath
/flag exch def
/polyarray exch def
/pcount polyarray length 2 idiv 1 sub def
polyarray aload pop moveto 
pcount {lineto} repeat
1 setlinewidth closepath flag 1 eq {fill} if stroke grestore
} def
%----- Define RASTER Polygon start 
/rps {gsave newpath
/yloc exch def
/xloc exch def
xloc yloc moveto } def
%----- Define RASTER Polygon end 
/rpe {
/flag exch def
1 setlinewidth closepath flag 1 eq {fill} if stroke grestore }def
%----- Define DONUT procedure 
%iradius oradius ypos xpos dn
/dn { gsave newpath
/xpos exch def
/ypos exch def
/oradius exch def
/iradius exch def
/radius oradius iradius add 2 idiv def
xpos ypos radius 0 360 arc
oradius iradius sub setlinewidth closepath stroke grestore
} def
%----- Define ARC procedure 
%xpos ypos radius theta1 theta2 linewidth ac
/ac { gsave newpath
/linewidth exch def
arc linewidth setlinewidth 1 setlinecap
stroke grestore 
} def
%----- Define CIRCLE procedure 
%xpos ypos radius fill_flag ci
/ci { gsave newpath
/flag exch def
0 360 arc 1 setlinewidth closepath
flag 1 eq {fill} if stroke grestore 
} def
%----- Define LINETOSKECTH procedure 
%x2 y2 x1 y1 lts
/lts { gsave newpath
moveto lineto
closepath 1 setlinewidth stroke grestore 
} def
%----- Define LINETO procedure 
%x2 y2 x1 y1 linecap linewidth ltd
/ltd { gsave newpath
/linewidth exch def
/linecap exch def
moveto lineto linewidth setlinewidth linecap setlinecap
stroke grestore 
} def
%----- Define MOVETO procedure 
%xpos ypos mv
/mv { moveto } def
%----- Define THERMAL (One Quandrant) procedure 
%x1, y1 x2 y2 theta2 phi2 theta1 phi1 cutsize oradius iradius
% ypos xpos linewidth fill_flag th
/th { gsave 
/fillflag exch def
/rotflag exch def
/linewidth exch def
/xpos exch def
/ypos exch def
/iradius exch def
/oradius exch def
/cutsize exch def
/ph1 exch def
/the1 exch def
/ph2 exch def
/the2 exch def
/y2 exch def
/x2 exch def
/y1 exch def
/x1 exch def
rotflag 1 eq {
	currentpoint
   xpos ypos translate 
	/x1 x1 xpos sub def
	/x2 x2 xpos sub def
	/y1 y1 ypos sub def
	/y2 y2 ypos sub def
	/xpos 0 def
	/ypos 0 def
	45 rotate
}if
newpath
xpos ypos oradius ph2 the2 arc
x1 y1 lineto
xpos ypos iradius the1 ph1 arcn
x2 y2 lineto
rotflag 1 eq {
   -45 rotate
	translate
} if
linewidth setlinewidth fillflag 1 eq {fill} if stroke grestore
} def
%----- Define THERMAL SKETCH procedure 
%theta2 phi2 radius ypos xpos ths
/ths {
/rotflag exch def
/xpos exch def
/ypos exch def
/radius exch def
/phi2 exch def
/theta2 exch def
theta2 phi2 radius ypos xpos 0 rotflag tha
theta2 90 add phi2 90 add radius ypos xpos 0 rotflag tha
theta2 180 add phi2 180 add radius ypos xpos 0 rotflag tha
theta2 270 add phi2 270 add radius ypos xpos 0 rotflag tha
} def
%----- Define THERMAL ARC procedure 
%theta2 phi2 radius yp xp linewidth rotflag tha
/tha { gsave
/rotflag exch def
/linewidth exch def
/xp exch def
/yp exch def
/radius exch def
/phi2 exch def
/theta2 exch def
rotflag 1 eq {
	currentpoint
   xp yp translate 
	/xp 0 def
	/yp 0 def
	45 rotate
}if
newpath
xp yp radius phi2 theta2 arc
rotflag 1 eq {
   -45 rotate
	translate
} if
linewidth setlinewidth stroke grestore 
} def
%----- Define THERMAL OUTLINE procedure 
%theta2 phi2 theta1 phi1 cutsize oradius iradius
% ypos xpos fill_flag tho
/tho {
/fillflag exch def
/rotflag exch def
/x exch def
/y exch def
/irad exch def
/orad exch def
/cuts exch def
/phii1 exch def
/th1 exch def
/phii2 exch def
/th2 exch def
 x cuts add y irad add x orad add y cuts add
 th2 phii2 th1 phii1 cuts orad irad
 y x 0 rotflag fillflag th
 x irad sub y cuts add x cuts sub y orad add
 90 th2 add 90 phii2 add 90 th1 add 90 phii1 add
 cuts orad irad y x 0 rotflag fillflag th
 x cuts sub y irad sub x orad sub y cuts sub
 180 th2 add 180 phii2 add 180 th1 add 180 phii1 add
 cuts orad irad y x 0 rotflag fillflag th
 x irad add y cuts sub x cuts add y orad sub
 270 th2 add 270 phii2 add 270 th1 add 270 phii1 add
 cuts orad irad y x 0 rotflag fillflag th
} def
%----- Define OBLONG procedure 
%ang1 ang2 x4 y4 x3 y3 x2 y2 x1 y1 xdst ydst xsrc ysrc
%wide fill_flag ob
/ob { gsave newpath
/flag exch def
/wide exch def
/ysrc exch def
/xsrc exch def
/ydst exch def
/xdst exch def
/y1 exch def
/x1 exch def
/y2 exch def
/x2 exch def
/y3 exch def
/x3 exch def
/y4 exch def
/x4 exch def
/ang2 exch def
/ang1 exch def
x2 y2 x1 y1 moveto lineto
xdst ydst wide 2 div ang1 ang2 arc
x4 y4 lineto
xsrc ysrc wide 2 div ang2 ang1 arc
1 setlinewidth flag 1 eq {fill} if stroke grestore
} def

/charheight { gsave newpath
	0 0 moveto
	false charpath
	flattenpath
	pathbbox							% stack = lx ly ux uy
	exch pop							% stack = lx ly uy
	3 -1 roll pop					% stack = ly uy
	grestore
}def

/stringheight {
/lly 0.0 def
/ury 0.0 def
   {
   	( ) dup 0 4 -1 roll put % create 1 char string
	   charheight              % measure its height
		dup ury gt {             % if uy > height max
		   /ury exch def         % update
		} {
		   pop                  % else discard
		} ifelse
		dup lly lt {             % if ly < height max
		   /lly exch def         % update
		} {
		   pop                  % else discard
		} ifelse

	} forall
	ury lly sub
}def

/doClip {
/x xpage xoff sub def
/y ypage yoff sub def
x neg y neg moveto
x y neg lineto
x y lineto
x neg y lineto
closepath clip newpath
}def

/doBorder {
initclip
/bordertext exch def
/x xpage xoff sub def
/y ypage yoff sub def
x neg y neg moveto
x y neg lineto
x y lineto
x neg y lineto
x neg y neg lineto 1 setlinewidth stroke
0 y neg moveto currentpoint % center of bottom line
bordertext
/textHgt bordertext stringheight def
/textWdt bordertext stringwidth pop  def
textWdt 2 div 
4 -1 roll exch sub
3 -1 roll textHgt 4 add sub moveto
currentpoint
1.0 setgray % clear a box for the text
0 textHgt rlineto
textWdt 0 rlineto
0 textHgt neg rlineto
closepath fill
0.0 setgray
moveto
show
} def

/fontSize 12.0 def % font size in points
/fontSize fontSize 13.88888 mul def % compensate for scaling
/BorderFont
   /Helvetica findfont fontSize scalefont def
BorderFont setfont
/xoff 0 def % amount to indent border in the x dimension in thousanths
/yoff 200 def % amount to indent border in the y dimension in thousanths
/xtrans 250 def % amount to offset image in the x dimension in thousanths
/ytrans 250 def % amount to offset image in the y dimension in thousanths
% END OF PS.INI
